/*
 * eGov Water and Sewerage(W&S)  System.
 * APIs for W&S module. This provide APIs for create new property, update existing property, search existing property. 
 *
 * OpenAPI spec version: 1.0.0
 * Contact: contact@egovernments.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import io.swagger.v3.oas.annotations.media.Schema;
/**
 * This is lightweight property object that can be used as reference by definitions needing property linking. Actual Property Object extends this to include more elaborate attributes of the property.
 */
@Schema(description = "This is lightweight property object that can be used as reference by definitions needing property linking. Actual Property Object extends this to include more elaborate attributes of the property.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-01-26T12:10:41.195Z[GMT]")
public class Connection {
  @JsonProperty("id")
  private String id = null;

  @JsonProperty("tenantId")
  private String tenantId = null;

  @JsonProperty("propertyId")
  private String propertyId = null;

  @JsonProperty("applicationNo")
  private String applicationNo = null;

  @JsonProperty("applicationStatus")
  private String applicationStatus = null;

  /**
   * Gets or Sets status
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    ACTIVE("Active"),
    INACTIVE("Inactive");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StatusEnum fromValue(String text) {
      for (StatusEnum b : StatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
    	  String value = jsonReader.nextString();
        return StatusEnum.fromValue(String.valueOf(value));
      }
    }
  }  @JsonProperty("status")
  private StatusEnum status = null;

  @JsonProperty("connectionNo")
  private String connectionNo = null;

  @JsonProperty("oldConnectionNo")
  private String oldConnectionNo = null;

  @JsonProperty("documents")
  private List<Document> documents = null;

  @JsonProperty("plumberInfo")
  private List<PlumberInfo> plumberInfo = null;

  @JsonProperty("roadType")
  private String roadType = null;

  @JsonProperty("roadCuttingArea")
  private Float roadCuttingArea = null;

  @JsonProperty("connectionExecutionDate")
  private Long connectionExecutionDate = null;

  @JsonProperty("connectionCategory")
  private String connectionCategory = null;

  @JsonProperty("connectionType")
  private String connectionType = null;

  @JsonProperty("additionalDetails")
  private Object additionalDetails = null;

  @JsonProperty("auditDetails")
  private AuditDetails auditDetails = null;

   /**
   * Unique Identifier of the connection for internal reference.
   * @return id
  **/
  @Schema(description = "Unique Identifier of the connection for internal reference.")
  public String getId() {
    return id;
  }

  public Connection tenantId(String tenantId) {
    this.tenantId = tenantId;
    return this;
  }

   /**
   * Unique ULB identifier.
   * @return tenantId
  **/
  @Schema(description = "Unique ULB identifier.")
  public String getTenantId() {
    return tenantId;
  }

  public void setTenantId(String tenantId) {
    this.tenantId = tenantId;
  }

  public Connection propertyId(String propertyId) {
    this.propertyId = propertyId;
    return this;
  }

   /**
   * UUID of the property.
   * @return propertyId
  **/
  @Schema(description = "UUID of the property.")
  public String getPropertyId() {
    return propertyId;
  }

  public void setPropertyId(String propertyId) {
    this.propertyId = propertyId;
  }

   /**
   * Formatted application number, which will be generated using ID-Gen at the time .
   * @return applicationNo
  **/
  @Schema(description = "Formatted application number, which will be generated using ID-Gen at the time .")
  public String getApplicationNo() {
    return applicationNo;
  }

   /**
   * Get applicationStatus
   * @return applicationStatus
  **/
  @Schema(description = "")
  public String getApplicationStatus() {
    return applicationStatus;
  }

   /**
   * Get status
   * @return status
  **/
  @Schema(description = "")
  public StatusEnum getStatus() {
    return status;
  }

   /**
   * Formatted connection number, which will be generated using ID-Gen service after aproval of connection application in case of new application. If the source of data is \&quot;DATA_ENTRY\&quot; then application status will be considered as \&quot;APROVED\&quot; application.
   * @return connectionNo
  **/
  @Schema(description = "Formatted connection number, which will be generated using ID-Gen service after aproval of connection application in case of new application. If the source of data is \"DATA_ENTRY\" then application status will be considered as \"APROVED\" application.")
  public String getConnectionNo() {
    return connectionNo;
  }

   /**
   * Mandatory if source is \&quot;DATA_ENTRY\&quot;.
   * @return oldConnectionNo
  **/
  @Schema(description = "Mandatory if source is \"DATA_ENTRY\".")
  public String getOldConnectionNo() {
    return oldConnectionNo;
  }

  public Connection documents(List<Document> documents) {
    this.documents = documents;
    return this;
  }

  public Connection addDocumentsItem(Document documentsItem) {
    if (this.documents == null) {
      this.documents = new ArrayList<Document>();
    }
    this.documents.add(documentsItem);
    return this;
  }

   /**
   * The documents attached by owner for exemption.
   * @return documents
  **/
  @Schema(description = "The documents attached by owner for exemption.")
  public List<Document> getDocuments() {
    return documents;
  }

  public void setDocuments(List<Document> documents) {
    this.documents = documents;
  }

  public Connection plumberInfo(List<PlumberInfo> plumberInfo) {
    this.plumberInfo = plumberInfo;
    return this;
  }

  public Connection addPlumberInfoItem(PlumberInfo plumberInfoItem) {
    if (this.plumberInfo == null) {
      this.plumberInfo = new ArrayList<PlumberInfo>();
    }
    this.plumberInfo.add(plumberInfoItem);
    return this;
  }

   /**
   * The documents attached by owner for exemption.
   * @return plumberInfo
  **/
  @Schema(description = "The documents attached by owner for exemption.")
  public List<PlumberInfo> getPlumberInfo() {
    return plumberInfo;
  }

  public void setPlumberInfo(List<PlumberInfo> plumberInfo) {
    this.plumberInfo = plumberInfo;
  }

  public Connection roadType(String roadType) {
    this.roadType = roadType;
    return this;
  }

   /**
   * It is a master data, defined in MDMS. If road cutting is required to established the connection then we need to capture the details of road type.
   * @return roadType
  **/
  @Schema(description = "It is a master data, defined in MDMS. If road cutting is required to established the connection then we need to capture the details of road type.")
  public String getRoadType() {
    return roadType;
  }

  public void setRoadType(String roadType) {
    this.roadType = roadType;
  }

  public Connection roadCuttingArea(Float roadCuttingArea) {
    this.roadCuttingArea = roadCuttingArea;
    return this;
  }

   /**
   * Capture the road cutting area in sqft.
   * @return roadCuttingArea
  **/
  @Schema(description = "Capture the road cutting area in sqft.")
  public Float getRoadCuttingArea() {
    return roadCuttingArea;
  }

  public void setRoadCuttingArea(Float roadCuttingArea) {
    this.roadCuttingArea = roadCuttingArea;
  }

   /**
   * Get connectionExecutionDate
   * @return connectionExecutionDate
  **/
  @Schema(description = "")
  public Long getConnectionExecutionDate() {
    return connectionExecutionDate;
  }

  public Connection connectionCategory(String connectionCategory) {
    this.connectionCategory = connectionCategory;
    return this;
  }

   /**
   * It is a master data, defined in MDMS
   * @return connectionCategory
  **/
  @Schema(required = true, description = "It is a master data, defined in MDMS")
  public String getConnectionCategory() {
    return connectionCategory;
  }

  public void setConnectionCategory(String connectionCategory) {
    this.connectionCategory = connectionCategory;
  }

  public Connection connectionType(String connectionType) {
    this.connectionType = connectionType;
    return this;
  }

   /**
   * It is a master data, defined in MDMS.
   * @return connectionType
  **/
  @Schema(required = true, description = "It is a master data, defined in MDMS.")
  public String getConnectionType() {
    return connectionType;
  }

  public void setConnectionType(String connectionType) {
    this.connectionType = connectionType;
  }

  public Connection additionalDetails(Object additionalDetails) {
    this.additionalDetails = additionalDetails;
    return this;
  }

   /**
   * Json object to capture any extra information which is not accommodated of model
   * @return additionalDetails
  **/
  @Schema(description = "Json object to capture any extra information which is not accommodated of model")
  public Object getAdditionalDetails() {
    return additionalDetails;
  }

  public void setAdditionalDetails(Object additionalDetails) {
    this.additionalDetails = additionalDetails;
  }

  public Connection auditDetails(AuditDetails auditDetails) {
    this.auditDetails = auditDetails;
    return this;
  }

   /**
   * Get auditDetails
   * @return auditDetails
  **/
  @Schema(description = "")
  public AuditDetails getAuditDetails() {
    return auditDetails;
  }

  public void setAuditDetails(AuditDetails auditDetails) {
    this.auditDetails = auditDetails;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Connection connection = (Connection) o;
    return Objects.equals(this.id, connection.id) &&
        Objects.equals(this.tenantId, connection.tenantId) &&
        Objects.equals(this.propertyId, connection.propertyId) &&
        Objects.equals(this.applicationNo, connection.applicationNo) &&
        Objects.equals(this.applicationStatus, connection.applicationStatus) &&
        Objects.equals(this.status, connection.status) &&
        Objects.equals(this.connectionNo, connection.connectionNo) &&
        Objects.equals(this.oldConnectionNo, connection.oldConnectionNo) &&
        Objects.equals(this.documents, connection.documents) &&
        Objects.equals(this.plumberInfo, connection.plumberInfo) &&
        Objects.equals(this.roadType, connection.roadType) &&
        Objects.equals(this.roadCuttingArea, connection.roadCuttingArea) &&
        Objects.equals(this.connectionExecutionDate, connection.connectionExecutionDate) &&
        Objects.equals(this.connectionCategory, connection.connectionCategory) &&
        Objects.equals(this.connectionType, connection.connectionType) &&
        Objects.equals(this.additionalDetails, connection.additionalDetails) &&
        Objects.equals(this.auditDetails, connection.auditDetails);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, tenantId, propertyId, applicationNo, applicationStatus, status, connectionNo, oldConnectionNo, documents, plumberInfo, roadType, roadCuttingArea, connectionExecutionDate, connectionCategory, connectionType, additionalDetails, auditDetails);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Connection {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    tenantId: ").append(toIndentedString(tenantId)).append("\n");
    sb.append("    propertyId: ").append(toIndentedString(propertyId)).append("\n");
    sb.append("    applicationNo: ").append(toIndentedString(applicationNo)).append("\n");
    sb.append("    applicationStatus: ").append(toIndentedString(applicationStatus)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    connectionNo: ").append(toIndentedString(connectionNo)).append("\n");
    sb.append("    oldConnectionNo: ").append(toIndentedString(oldConnectionNo)).append("\n");
    sb.append("    documents: ").append(toIndentedString(documents)).append("\n");
    sb.append("    plumberInfo: ").append(toIndentedString(plumberInfo)).append("\n");
    sb.append("    roadType: ").append(toIndentedString(roadType)).append("\n");
    sb.append("    roadCuttingArea: ").append(toIndentedString(roadCuttingArea)).append("\n");
    sb.append("    connectionExecutionDate: ").append(toIndentedString(connectionExecutionDate)).append("\n");
    sb.append("    connectionCategory: ").append(toIndentedString(connectionCategory)).append("\n");
    sb.append("    connectionType: ").append(toIndentedString(connectionType)).append("\n");
    sb.append("    additionalDetails: ").append(toIndentedString(additionalDetails)).append("\n");
    sb.append("    auditDetails: ").append(toIndentedString(auditDetails)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
